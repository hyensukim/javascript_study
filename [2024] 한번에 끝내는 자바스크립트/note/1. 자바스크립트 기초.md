## Chpater01 자바스크립트 실행 환경

자바스크립트는 자바스크립트 엔진이 있는 모든 곳에서 동작한다.
웹브라우저 안에는 자바스크립트 엔진이 포함되어 있다. ex) Chrome -> V8 엔진
이와 같은 웹브라우저를 자바스크립트 실행 환경(런타임)이라고 한다.

Plugin 설치

- Prettier
- Live Server

## Chapter02 변수와 상수

변수 : 어떠한 값을 저장하기 위한 공간

상수 : 변하지 않는 값을 저장하는 공간

변수 명명 규칙

- $ \_ 기호를 제외한 특문으로 변수명을 작성할 수 없다.
- 변수명 제일 앞에 숫자를 사용할 수 없다.
- 변수명으로 예약어를 사용할 수 없다.

긴 변수명 표기법 : 둘 이상의 단어를 하나의 변수명으로 지정 시 사용.

- 카멜 표기법 : isDogOrCat
- 스네이크 표기법 : is_dog_or_cat
- 파스칼 표기법 : IsDogOrCat
- 상수 표기법 : IS_DOG_OR_CAT

변수 선언

- let name = "현수";

상수 선언

- const name = "현수";

상수를 사용하는 이유

- 변하지 않는 값을 저장하기 위해 사용. ex) 생일, 이름, 주민번호

## Chapter03 변수의 자료형과 형변환

자료형 : 변수에 할당되는 값의 종류

- 원시타입 : 런타임 시 단일 값만 저장하는 변수
- 참조타입 : 런타임 시 다중 값을 저장하는 변수
  - 실제로는 **참조값**을 저장하며, 이 참조값에 해당하는 메모리 안에 여러 값을 저장한다.

형변환

- 프로그램 실행 중에 자동으로 자료형이 변환된다.
- 따라서, 변수 앞에는 자료형을 명시하지 않고, 선언자라는 것을 함께 작성해준다.
- 자바스크립트 언어는 동적 타입 언어로, 자동으로 타입이 지정된다.(자유로움)

## Chapter04 연산자

null병합 연산자 : 변수에 null 또는 undefined 인 경우를 대비하여 기본값을 지정할 때, 주로 사용함.

typeof 연산자 : 변수의 자료형을 확인하기 위해 사용함.

## Chapter05 조건문

Skip

## Chapter06 함수

- 함수를 사용하는 이유는 로직 내 동일한 기능을 하는 코드들의 중복을 방지하고, 이를 재사용하여 가독성 및 유지보수에 용이하도록 해준다.
- 함수는 선언 후에 호출해줘야만 내부 로직을 수행한다.
- 함수 선언 시 소괄호 안에 정의하는 변수를 '매개변수'라고 한다.
- 함수 선언 시 return 뒤에 오는 값을 '반환값'이라고 한다.
- js 내부에는 다른 함수의 선언이 가능하며, 이를 '중첩함수'라고 한다.
- 함수 호출 시 전달되는 값을 '인수'라고 한다.

## Chapter07 스코프

- 스코프 : 변수와 함수가 영향을 미치는 범위
  - 전역 스코프 : 전역 변수는 전역 스코프를 갖으며, 어디에서나 접근이 가능하다.
  - 지역 스코프 : 지역 스코프의 변수는 접근 가능 범위(중괄호)에서만 유효하다.
    - 함수 스코프 : var로 정의 -> 동일명의 변수를 중복 선언이 가능하며, 가장 마지막에 선언된 변수의 값이 설정되므로 오류의 원인이 될 가능성이 크므로 사용 X
    - 블록 스코프 : let/const으로 정의 시 블록 내에서만 유효하도록 값이 설정됨.(ES6 이후부터 사용)

## Chapter08 호이스팅

- 변수와 함수의 선언문이 가장 상위로 끌어올려지는 것과 같이 사용되는 것을 의미함.
- 이는 자바스크립트 엔진이 함수 호출보다 선언문을 우선 인식하기 때문이다.
- 변수의 호이스팅
  - var 선언자 사용 시, var로 선언된 변수는 호이스팅이 발생한다.
  - 이로 인해, var로 선언된 변수는 선언문 위에서 사용될 수 있다.
  - 반면에, let과 const 선언자로 선언 시에는 해당 변수가 초기화 되기 전까지 TDG(Temporal Dead Zone) 안에 보관되므로, 오류가 발생하도록 해주는 것이다.
    - TDG : 변수 초기화 전까지 사용이 불가능하도록 설정하기 위한 공간
  - 즉, 호이스팅은 js의 기본적인 특징이지만 변수 선언 및 사용 시에는 오류의 원인이 될 확률이 크므로, 가급적 선언자는 let과 const를 활용하여 사용해준다.

## Chapter09 함수 표현식과 화살표 함수

- 화살표 함수는 화살표가 포함된 함수로, ES6 이후의 문법이다.
- 화살표 함수는 함수를 쉽게 사용할 수 있도록 도와주며, 이를 통해 함수 표현식으로 나타낼 수 있다.

- 함수 표현식 : 변수에 함수를 마치 하나의 값처럼 할당
- 함수 선언식 : function 키워드 옆에 함수의 이름 작성
- 큰 차이점 :
  - 함수 선언식 - 호이스팅이 가능, 함수 표현식 - 호이스팅 불가
  - 함수 선언식 - 함수명 필수, 함수 표현식 - 필요 X
- 콜백함수 : 다른 함수의 인수로 넘겨준 함수를 의미.
  - 사용이 간단하기 떄문에, 일반적으로 콜백함수로 함수 표현식을 사용한다.

## Chapter10 객체

- 비원시 타입
- 한번에 연관된 여러개의 데이터 값을 저장할 수 있는 자료형
- 예를 들어, 사람을 설명하기 위해서 사람의 다양한 정보를 저장한다. 사람을 객체로 만든다고 한다면, 다양한 정보를 하나로 묶어야 한다.
- 객체 생성하는 방법으로는 객체 생성자 함수, 리터럴이 있다. 일반적으로 간단한 리터럴을 사용한다.
- 객체 내 값들은 K-V 형태로 저장되며, 이를 '프로퍼티' 라고 한다.
- 프로퍼티의 key는 고유값이며, value로는 어떠한 타입의 값도 담을 수 있다.
- 프로퍼티로 함수도 담을 수 있으며, 이를 '메서드'라고 한다.
- 메서드는 this 키워드를 활용하여 객체 내 모든 프로퍼티에 접근이 가능하다.
- 하지만, 이를 위해서는 함수 선언식으로 메서드를 정의해줘야 한다. 화살표 함수의 경우, this 키워드 사용 시 window 객체를 참조하게 되므로, 객체 내 프로퍼티에 접근이 불가능하게 된다.

## Chapter11 배열

- 비원시 타입
- 객체와 다르게 순서가 있는 데이터들의 집합이다.
- 배열과 객체의 차이점
  - 리터럴
  - 요소 형태
- 배열 생성
  - 배열 생성자 함수
  - 배열 리터럴
- 배열 사용
  - 해당 요소 선택 : [index]
  - 요소 추가 : push(맨뒤), unshift(맨앞 - 성능 저하)
  - 요소 삭제 : pop(맨뒤), splice(start,end)
  - 배열 길이 : .length

## Chpater12 생성자 함수

- 객체와 배열을 생성하는 방법으로 'new' 예약어를 사용.
- 생성자 함수는 동일한 구조의 객체를 쉽게 생성하기 위해서 사용된다.(재사용 향상)
- 생성자 함수로 생성된 객체를 '인스턴스'라고 한다.

## Chapter13 반복문

- 특정 작업을 반복적으로 수행할 때 사용.
- 배열/객체에 접근 시 유용하게 사용된다.
- 객체를 배열로 변환하는 방법
  - Object.keys() : 객체의 Key 값들로 구성된 배열 생성
  - Object.values() : 객체의 Value 값들로 구성된 배열 생성
  - Object.entiries() : 객체의 Key와 Value를 담은 새로운 배열 생성
- for of문 : 배열에서 주로 사용
- for in문 : 객체에서 주로 사용

## Chapter14 배열 메서드 - 1

- 배열 내장함수
  - push : 배열 요소 맨 뒤에 요소 추가
  - unshifte : 배열 맨 앞에 요소 추가
  - at : 가장 마지막 요소에 쉽게 접근할 수 있는 내장 함수
  - includes : 내부에 값이 존재하는 지 확인하기 위한 내장 함수
  - indexOf : 내부에 값의 인덱스를 확인하기 위한 내장 함수
  - findIndex : 배열의 요소가 객체인 경우, 특정 요소의 값이 어떤 인덱스에 존재하는지 확인하기 위한 내장함수
  - find : 특정 요소의 객체 자체를 확인하기 위한 내장 함수
  - filter : 특정 요소 필터링하기 위한 내장 함수
  - slice : 특정 요소를 담은 새로운 배열을 생성하기 위한 내장 함수

## Chapter15 배열 메서드 - 2

- 배열 내장함수

  - concat : 두 배열을 하나의 배열로 합쳐주는 내장 함수
  - join : 배열을 하나로 합치기 위한 함수, 하나의 배열에서 배열 요소들을 하나의 문자열로 출력.
    - 인수는 구분자를 의미함.
  - sort : 배열 요소 정렬을 위한 내장 함수

    - 기본값 : 오름차순
    - 한번 설정 시 실제 배열 내 요소들이 정렬된다.
    - compare 함수 사용하여 정렬 기준 설정

      ```js
      const compare = (a, b) => {
        // a : 배열의 다음 요소, b : 배열의 이전 요소
        if (a > b) return -1;
        else if (a < b) return 1;
        else return 0;
      };

      const compare = (a, b) => a - b; //오름차순
      const compare = (a, b) => b - a; //내림차순
      ```

  - reduce: 배열 요소에 함수를 수행하고, 누적된 값을 위해 사용하는 내장함수.

  - isArray : 배열 객체인지 여부를 확인하기 위한 내장함수.

## Chapter16. 배열과 객체의 구조 분해 할당

- 배열이나 객체의 요소 및 프로퍼티들을 분해하여, 값들을 각각의 변수에 할당하는 자바스크립트의 표현식을 말한다.
- 선언과 동시에 값을 배열의 값을 할당하기 위해서 사용할 수 있다.
- 두 변수의 값을 교환하는 경우에도 유용하게 사용된다.
  ```js
  let a = 10;
  let b = 5;
  console.log(a, b); // 10 5
  [a, b] = [b, a];
  console.log(a, b); // 5 10
  ```
- 배열과 객체 구조 분해 할당
  - 배열은 어떤 변수명이든 순서만 맞는다면 구조 분해 할당이 가능.
  - 객체는 프로퍼티와 동일한 키값을 변수명으로 지정해야 분해 할당이 가능.
    - 별칭 지정 가능.(property1 : v1) -> v1에 property1의 value가 담긴다.
- 기본값 설정
  - 배열과 객체 모두 배열 요소 또는 객체 요소보다 많은 변수로 할당 시, 초과된 변수에는 undefined 된 값으로 초기화된다.
  - 이를 방지하고자, 변수명 옆에 "= 기본값" 과 같이 기본값을 설정해줄 수 있다.

## Chapter17. spread와 rest

- spread : 객체나 배열에서 중복된 내용을 사용, 함수 호출 시 인수로 전달할 값을 여러개로 전달할 때 사용.
- rest : 객체나 배열에서 특정부분을 하나의 객체나 배열로 묶을 때, 함수의 매개변수로 많은 값을 전달받거나 이를 하나의 배열로 받을 때 사용.
