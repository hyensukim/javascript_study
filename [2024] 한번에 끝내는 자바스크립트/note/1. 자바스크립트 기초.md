## Chpater01 자바스크립트 실행 환경

자바스크립트는 자바스크립트 엔진이 있는 모든 곳에서 동작한다.
웹브라우저 안에는 자바스크립트 엔진이 포함되어 있다. ex) Chrome -> V8 엔진
이와 같은 웹브라우저를 자바스크립트 실행 환경(런타임)이라고 한다.

Plugin 설치

- Prettier
- Live Server

## Chapter02 변수와 상수

변수 : 어떠한 값을 저장하기 위한 공간

상수 : 변하지 않는 값을 저장하는 공간

변수 명명 규칙

- $ \_ 기호를 제외한 특문으로 변수명을 작성할 수 없다.
- 변수명 제일 앞에 숫자를 사용할 수 없다.
- 변수명으로 예약어를 사용할 수 없다.

긴 변수명 표기법 : 둘 이상의 단어를 하나의 변수명으로 지정 시 사용.

- 카멜 표기법 : isDogOrCat
- 스네이크 표기법 : is_dog_or_cat
- 파스칼 표기법 : IsDogOrCat
- 상수 표기법 : IS_DOG_OR_CAT

변수 선언

- let name = "현수";

상수 선언

- const name = "현수";

상수를 사용하는 이유

- 변하지 않는 값을 저장하기 위해 사용. ex) 생일, 이름, 주민번호

## Chapter03 변수의 자료형과 형변환

자료형 : 변수에 할당되는 값의 종류

- 원시타입 : 런타임 시 단일 값만 저장하는 변수
- 참조타입 : 런타임 시 다중 값을 저장하는 변수
  - 실제로는 **참조값**을 저장하며, 이 참조값에 해당하는 메모리 안에 여러 값을 저장한다.

형변환

- 프로그램 실행 중에 자동으로 자료형이 변환된다.
- 따라서, 변수 앞에는 자료형을 명시하지 않고, 선언자라는 것을 함께 작성해준다.
- 자바스크립트 언어는 동적 타입 언어로, 자동으로 타입이 지정된다.(자유로움)

## Chapter04 연산자

null병합 연산자 : 변수에 null 또는 undefined 인 경우를 대비하여 기본값을 지정할 때, 주로 사용함.

typeof 연산자 : 변수의 자료형을 확인하기 위해 사용함.

## Chapter05 조건문

Skip

## Chapter06 함수

- 함수를 사용하는 이유는 로직 내 동일한 기능을 하는 코드들의 중복을 방지하고, 이를 재사용하여 가독성 및 유지보수에 용이하도록 해준다.
- 함수는 선언 후에 호출해줘야만 내부 로직을 수행한다.
- 함수 선언 시 소괄호 안에 정의하는 변수를 '매개변수'라고 한다.
- 함수 선언 시 return 뒤에 오는 값을 '반환값'이라고 한다.
- js 내부에는 다른 함수의 선언이 가능하며, 이를 '중첩함수'라고 한다.
- 함수 호출 시 전달되는 값을 '인수'라고 한다.

## Chapter07 스코프

- 스코프 : 변수와 함수가 영향을 미치는 범위
  - 전역 스코프 : 전역 변수는 전역 스코프를 갖으며, 어디에서나 접근이 가능하다.
  - 지역 스코프 : 지역 스코프의 변수는 접근 가능 범위(중괄호)에서만 유효하다.
    - 함수 스코프 : var로 정의 -> 동일명의 변수를 중복 선언이 가능하며, 가장 마지막에 선언된 변수의 값이 설정되므로 오류의 원인이 될 가능성이 크므로 사용 X
    - 블록 스코프 : let/const으로 정의 시 블록 내에서만 유효하도록 값이 설정됨.(ES6 이후부터 사용)

## Chapter08 호이스팅

- 변수와 함수의 선언문이 가장 상위로 끌어올려지는 것과 같이 사용되는 것을 의미함.
- 이는 자바스크립트 엔진이 함수 호출보다 선언문을 우선 인식하기 때문이다.
- 변수의 호이스팅
  - var 선언자 사용 시, var로 선언된 변수는 호이스팅이 발생한다.
  - 이로 인해, var로 선언된 변수는 선언문 위에서 사용될 수 있다.
  - 반면에, let과 const 선언자로 선언 시에는 해당 변수가 초기화 되기 전까지 TDG(Temporal Dead Zone) 안에 보관되므로, 오류가 발생하도록 해주는 것이다.
    - TDG : 변수 초기화 전까지 사용이 불가능하도록 설정하기 위한 공간
  - 즉, 호이스팅은 js의 기본적인 특징이지만 변수 선언 및 사용 시에는 오류의 원인이 될 확률이 크므로, 가급적 선언자는 let과 const를 활용하여 사용해준다.

## Chapter09 함수 표현식과 화살표 함수

- 화살표 함수는 화살표가 포함된 함수로, ES6 이후의 문법이다.
- 화살표 함수는 함수를 쉽게 사용할 수 있도록 도와주며, 이를 통해 함수 표현식으로 나타낼 수 있다.

- 함수 표현식 : 변수에 함수를 마치 하나의 값처럼 할당
- 함수 선언식 : function 키워드 옆에 함수의 이름 작성
- 큰 차이점 :
  - 함수 선언식 - 호이스팅이 가능, 함수 표현식 - 호이스팅 불가
  - 함수 선언식 - 함수명 필수, 함수 표현식 - 필요 X
- 콜백함수 : 다른 함수의 인수로 넘겨준 함수를 의미.
  - 사용이 간단하기 떄문에, 일반적으로 콜백함수로 함수 표현식을 사용한다.

## Chapter10 객체

- 비원시 타입
- 한번에 연관된 여러개의 데이터 값을 저장할 수 있는 자료형
- 예를 들어, 사람을 설명하기 위해서 사람의 다양한 정보를 저장한다. 사람을 객체로 만든다고 한다면, 다양한 정보를 하나로 묶어야 한다.
- 객체 생성하는 방법으로는 객체 생성자 함수, 리터럴이 있다. 일반적으로 간단한 리터럴을 사용한다.
- 객체 내 값들은 K-V 형태로 저장되며, 이를 '프로퍼티' 라고 한다.
- 프로퍼티의 key는 고유값이며, value로는 어떠한 타입의 값도 담을 수 있다.
- 프로퍼티로 함수도 담을 수 있으며, 이를 '메서드'라고 한다.
- 메서드는 this 키워드를 활용하여 객체 내 모든 프로퍼티에 접근이 가능하다.
- 하지만, 이를 위해서는 함수 선언식으로 메서드를 정의해줘야 한다. 화살표 함수의 경우, this 키워드 사용 시 window 객체를 참조하게 되므로, 객체 내 프로퍼티에 접근이 불가능하게 된다.

## Chapter11 배열

- 비원시 타입
- 객체와 다르게 순서가 있는 데이터들의 집합이다.
- 배열과 객체의 차이점
  - 리터럴
  - 요소 형태
- 배열 생성
  - 배열 생성자 함수
  - 배열 리터럴
- 배열 사용
  - 해당 요소 선택 : [index]
  - 요소 추가 : push(맨뒤), unshift(맨앞 - 성능 저하)
  - 요소 삭제 : pop(맨뒤), splice(start,end)
  - 배열 길이 : .length
