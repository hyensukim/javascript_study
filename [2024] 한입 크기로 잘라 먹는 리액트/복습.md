복습

자료형

- Number
  - NaN : 연산 실패 시 결과 ex) "이름" \* 1;
- String
  - 템플릿 리터럴 (``) 백틱 사용, 내부에서 동적인 값 사용 시 (${} - 플레이스 홀더) 사용
- undefined
  - 선언 후 값을 초기화 하지 않으면 넣는 디폴트 값.
- null
  - 의도적으로 빈값이라고 초기화하는 값.
- Boolean
  - 참 /거짓

템플릿 리터럴

- 내장된 표현식을 허용하는 문자열 리터럴.
- 여러 줄의 문자열과 보간기능을 사용할 수 있다.
- ES2015 버전의 사양 명세에서는 템플릿 문자열 이라고 명명되었다.

함수

- 중복된 로직을 줄이기 위해 유사한 기능을 하는 코드를 정의한 것을 함수라고 한다.
- 괄호 안에 값은 호출 시, 인수 - 선언 시 매개변수 라고 한다.
- 함수의 호이스팅이 가장 중요한데, 함수는 선언만 하면, 어느 곳에서든 호출이 가능하다. 심지어, 함수가 선언된 위의 줄에서도 호출 가능.

함수 표현식과 화살표 함수

- 기본 함수 생성식

  ```js
  // 선언
  function func1() {
    console.log("function1!");
  }
  // 호출
  func1();
  ```

- 익명함수 표현식

  ```js
  let func2 = function () {
    console.log("function2");
  };
  func2();
  ```

- 화살표 함수
  ```js
  let func3 = () => {
    console.log("function3");
  };
  func3();
  ```

콜백함수

- 자신이 아닌 다른 함수에 인수로써 전달되는 함수.
- 함수를 인수로 사용함으로써, 실제 선언 시 사용되는 함수 로직은 줄어들어 중복 코드가 준다.
- 예시

  ```js
  funciton repeat(count, callback){
    for(let i = 0; i < count; i++) {
        callback(i);
    }
  }

  repeat(10, (i)=>{
    console.log(i);
  });
  ```

스코프

- 변수나 함수에 접근할 수 있는 범위.
- 전역 스코프, 지역 스코프로 구분.
- 전역 - 코드 전구역에서 접근 가능.
- 지역 - 특정 영역(중괄호 == 블록) 안에서 접근 가능.
- 함수는 중복 함수 선언 시, 지역 스코프를 갖는다.
- 예시

  ```js
  let a = 10;

  if (a == 10) {
    let b = 100;
    console.log(a);
    console.log(b);
  }

  // console.log(b); // Uncaught ReferenceError: b is not defined
  ```

객체

- 여러개의 값을 동시에 저장할 수 있는 자료형
- 원시 타입이 아닌 객체 타입의 자료형
- 객체 생성
  - new Object();
  - {} : 객체 리터럴(많이 사용)
- 프로퍼티
  - 객체의 속성, k-V 형태로 저장.
- 프로퍼티 사용
  - 접근
    - 점 : 객체명.프로퍼티명;
    - 괄호 : 객체명["프로퍼티명"];
  - 추가
  - 수정
  - 삭제
    - delete 객체명.프로퍼티명; | delete 객체명["프로퍼티명"];
- in 연산자 : 프로퍼티의 존재 유무를 확인
  - "프로퍼티명" in 객체명;
- 상수 객체 : 상수에 객체를 저장해 놓은 형태, 프로퍼티는 사용 가능.
- 메서드 : 객체 내 정의된 함수 타입의 프로퍼티.

배열

- 객체와 동일하게 여러개의 값을 저장할 수 있지만, **순차적**으로 담는 자료형.
- 순서가 존재하므로, 인덱스가 있다.(0부터 시작)
- 배열 생성
  - new Array();
  - [] : 배열 리터럴(많이 사용)
- 접근 시, 배열 인덱스로 접근 가능.

배열 메서드

1. 요소 조작
   - push : 배열 끝에 요소를 추가, 추가 후 배열의 길이를 반환.
   - pop : 배열 끝에 요소를 제거, 제거 후 해당 요소를 반환.
   - shift : 배열 앞에 요소를 제거, 제거 후 해당 요소를 반환.
   - unshift : 배열 앞에 요소를 추가, 추가 후 배열의 길이를 반환.
     - shift와 unshift는 push와 pop 보다 성능이 저하된다.
       - shift와 unshift는 요소 전체의 인덱스가 바뀌어야 하기 때문.
   - slice : 배열의 특정 범위를 잘라내서 새로운 배열 반환.
   - concat : 두 개의 다른 배열을 이어 붙여서 새로운 배열을 반환.
2. 요소 순회 및 탐색
   - forEach : 모든 요소 순회하여, 콜백함수를 통해 각 요소에 특정 동작을 수행시키는 메서드. 인수로 item(요소), index(인덱스), arr(배열)을 받을 수 있다.
   - incluedes : 배열 안에 특정 요소가 있는지 확인하는 메서드.
   - indexOf : 특정 요소의 인덱스를 찾아서 반환하는 메서드.
     - 동일 요소가 존재할 경우, 앞에서부터 찾으므로, 앞쪽에 인덱스 반환.
     - 요소가 존재하지 않을 경우, -1 반환.
   - findIndex : 모든 요소 순회하며, 콜백함수를 만족하는 특정 요소 인덱스를 반환하는 메서드.
     - indexOf 로는 객체 타입의 요소를 탐색할 수 없기 때문에, 그러한 경우 findIndex로 탐색하여 깊은 비교를 한다.
   - find : findIndex와 동일한 기능을 하지만, 객체를 반환함.
3. 배열 자료형 변형

   - filter : 기존 배열에서 조건을 만족하는 요소들만 모아서 새로운 배열로 반환.
   - map : 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 그 결과값들을 모아서 새로운 배열을 만들어 반환.
   - sort : 배열을 사전순으로 정렬하는 메서드, 숫자형의 경우 대소 비교이므로 이는 별도로 sort 인수로 기준을 정의해줘야 한다.

     - 예시

       ```js
       // 오름차순
       let arr = [2, 1, 6, 4, 3, 5];
       arr.sort((a, b) => {
         if (a > b) {
           return 1;
         } else if (a < b) {
           return -1;
         } else {
           return 0;
         }
       });
       console.log(arr);

       //내림차순
       arr.sort((a, b) => {
         if (a > b) {
           return -1;
         } else if (a < b) {
           return 1;
         } else {
           return 0;
         }
       });
       console.log(arr);
       ```

   - toSorted : 정렬된 새로운 배열을 반환하는 메서드.

Truthy 와 Falsy

- 자바스크립트 내 모든 값들은 참과 거짓으로 구분된다.
- falsy 한 값 : 0n, 0, -0, NaN, "", undefined, null
- Truthy 한 값 : falsy 한 값을 제외한 모든 값 ex) {}, [], " ", "as", 12

단락평가

- 논리 연산자를 통해 두 항의 참/거짓 여부 판단 시, 첫번째 항에서 논리 연산의 결과가 확정되면, 두번째 항의 연산을 수행하지 않는 것.
- 예시

  ```js
  function printName(person) {
    let name = person && person.name;
    console.log(name || "person 값이 없음");
  }

  printName({ name: "이름" }); // 이름
  printName(undefined); // person 값이 없음
  printName(null); // person 값이 없음
  ```

구조 분해 할당

- 배열이나 객체에 저장된 여러 개의 값을 분해해서 각각 다른 변수에 할당하는 것을 의미.
- 객체 구조 분해 할당 시, 객체 프로퍼티 명과 동일한 변수명을 선언해줘야 한다.
- 예시

  ```js
  let arr = [1, 2, 3];
  let [a, b, c] = arr;
  console.log(a, b, c); // 1 2 3

  let obj = { a: 1, b: 2, c: 3 };
  let { a, b, c } = obj;
  console.log(a, b, c); // 1 2 3

  const func = ({ name, age }) => {
    console.log(name, age);
  };

  let person = {
    name: "사람",
    age: 20,
  };

  func(person);
  ```

스프레드 연산자

- 객체나 배열에 저장된 다수의 값을 개별로 흩뿌려주는 역할.
- 예시

  ```js
  let arr = [1, 2, 3];
  let arr2 = [...arr, 4, 5, 6];
  console.log(arr2);

  let obj = { a: 1, b: 2, c: 3 };
  let obj2 = { ...obj, d: 4, e: 5, f: 6 };
  console.log(obj2);
  ```

rest 매개변수

- 나머지 매개변수를 의미하며, 여러 인자를 받아서 함수 내에서 배열 형태로 사용할 수 있도록 해주는 예약어.
- 예시

  ```js
  function funcA(...rest) {
    for (let r of rest) {
      console.log(r);
    }
  }
  let arr1 = [1, 2, 3];
  funcA(...arr1); // 1 2 3

  funcA(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
  ```

// chapter 5,6,10,11,12,13,14
