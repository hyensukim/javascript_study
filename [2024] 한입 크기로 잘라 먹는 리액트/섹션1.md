> 출처 : [한입 크기로 잘라먹는 리액트 - 이정환](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%EB%A6%AC%EC%95%A1%ED%8A%B8/dashboard)

## 자바스크립트의 기원

- 정적인 웹 페이지를 동적으로 바꿔주기 위해 사용.

## 자바스크립트는 어떻게 동작할까?

- 자바스크립트 엔진을 통해서 실행.
- 대표적으로 Chrome에 V8 엔진이 있음.
- 일반적으로 웹 브라우저 내 콘솔은 간단한 테스트용으로만 사용되고 실제 개발에서 사용하기에는 불편함.

## VsCode 설치

- [VsCode 공식문서](https://code.visualstudio.com/)
- 설정바 단축키 : `ctrl + ,`
- 유용한 플러그 인
  - Prettier - Code Formatter
  - Material Icon Theme
  - Error lens
  - Live Server

## 자바스크립트 실습 환경 설정

- index.html 파일
  - vsCode 기능 검색창 단축키 : `ctrl + shift + p`
  - live server : open ~ -> 라이브 페이지 실행.

## 자바스크립트 기본 문법

### 👀 변수와 상수

- 값을 담는 공간
- 변수 : 값을 바꿔가면서 저장할 수 있는 공간
  - let 선언자
  - 중복 선언 불가
- 상수 : 초기화 후 변경이 불가한 저장 공간
  - const 선언자
  - 중복 선언 불가

### 👀 변수 명명 규칙(네이밍 규칙)

1. $,\_ 제외한 특수기호는 사용할 수 없다.
2. 변수의 이름은 숫자로 시작할 수 없다.
3. 예약어를 사용할 수 없다.

### 👀 자료형

- 원시타입
  - Number
    - Infinity / -Infinity : 무한 / 음수무한
    - NaN : 연산 실패 시 결과
  - String
    - \*템플릿 리터럴 문법
  - Boolean
  - Null : 개발자가 직접 값이 없음을 나타낼 때 대입.
  - Undefined : 변수 초기화 하지 않거나, 의도치 않게 빈 결과 반환 시 자동으로 대입되어 있는 값.
- 객체타입
  - Object
    - Array
    - Function
    - RegexEpx

#### ⭐ 템플릿 리터럴 (참고 : [Mdn - Template Literals](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals))

- 템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다.
- 여러 줄로 이뤄진 문자열과 문자 보간기능을 사용할 수 있다.
- 이전 ES2015 버전의 사양 명세에서는 "템플릿 문자열" 이라고 명명되어 왔다.

```
`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`
```

- 템플릿 리터럴은 백틱(``)을 이용하여 사용한다.
- 플레이스 홀더를 이용하여 표현식을 추가할 수 있는데, 이는 $와 중괄호({})로 표기할 수 있다.
- ❌ 템플릿 리터럴 앞에 어떤 표현식이 있다면, 해당 템플릿에는 표현식이 지정된 템플릿이 된다.

```js
`\`` === "`"; // --> true
```

주요 특징

- Multi-line strings : 여러 문자열을 쉽게 표현 가능.
- 표현식 삽입법 : 플레이스 홀더를 활용하여 간단하게 삽입 가능.
- 중첩 템플릿 리터럴 사용 가능 : 백틱 안에 백틱 사용 가능.
- ❌ tagged templates : 태그를 사용한 템플릿 리터럴로써, 템플릿 리터럴을 함수로 파싱 할 수 있다.

### 👀 형변환

- 묵시적 형변환 : 자바스크립트 내부적으로 형변환을 해줌.
  - 문자열 + 숫자 연산 : 숫자를 묵시적으로 문자열로 형변환 수행.
- 명시적 형변환 : 자바스크립트 내장함수 등을 활용하여 개발자가 직접 형변환을 해줘야 함.
  - 문자열 -> 숫자
    - Number() : 문자열에 숫자만 포함되어 있는 경우 사용. ex) "10"
    - parseInt() : 문자열에 글자와 숫자가 함께 있는 경우 사용. ex) "10개"
      - 주의할 점은 숫자가 글자보다 항상 앞에 있어야 한다. ex) "총10개" -> NaN
  - 숫자 -> 문자열
    - String() : 숫자를 문자열로 변환할 경우 사용

### 👀 연산자

- 기본 연산자는 다른 언어와 크게 다르지 않음.
- 다만, 동등/비동등 비교 시 '==='와 '=='의 차이가 있다.
  - === : 값 + 타입 비교 ex) 1 === "1" // false
  - == : 값만 비교 ex) 1 == "1" // true
- 특수한 연산자
  1. null 병합 연산자
  - 값이 null 또는 undefined가 아닌 값을 찾아내기 위한 연산자.
  2. typeof 연산자
  - 해당 변수의 타입을 문자열로 출력하기 위한 연산자.
  3. 삼항 연산자
  - 조건식을 이용하여 참과 거짓일 때의 값을 동적으로 다르게 반환해주는 연산자.

### 👀 조건문

- 조건을 이용하여 참과 거짓에 따라 다른 로직을 수행 시 사용하는 문법.
- 다른 언어와 동일함.

### 👀 반복문

- 동작을 반복해서 수행 시 사용하는 문법.
- 다른 언어와 동일함.

### ⭐ 함수

- 코드를 작성하다 보면, 중복으로 작성된 유사한 기능을 하는 코드가 발생한다.
- 이는 개발 생산성을 저하하고, 유지보수에 어려움을 발생시킬 수 있다.
- 이를 해결하고자 함수라는 것을 사용한다.
- 함수는 선언한다고 실행되지 않는다. 호출을 해줘야 한다.
- 함수 선언 시 외부에서 전달 받는 변수를 "매개변수" 라고 한다.
- 함수 선언 시 외부로 반환하는 값을 "반환값" 이라고 한다.
- 자바스크립트는 함수 내부에 다른 함수 선언이 가능하며, 이를 "중첩함수"라고 한다.
- 매개변수가 함께 선언된 함수를 호출 시 전달되는 값을 "인수"라고 한다.
- **함수의 호이스팅** : 자바스크립트는 함수 호출 이후에 선언하더라도 정상적으로 동작하는데, 이를 함수의 호이스팅이라고 한다.

### ⭐ 함수 표현식과 화살표 함수

- 함수를 표현하는 방식으로 다음과 같이 있다.
  - 함수 선언 - 호이스팅 O
  - 익명 함수 - 함수를 선언하지 않음, 변수 초기화 시 값으로 함수를 담음, 호이스팅 X
  - 화살표 함수 - 익명 함수의 화살표 형태, 형식이 자유로움, 호이스팅 X

### ⭐ 콜백함수

- 자신이 아닌 다른 함수에 인수로써 전달되는 함수를 의미한다.
- 이를 통해 콜백함수를 매개변수로 받는 함수 안에서 콜백함수를 원하는 시점에 호출 및 제어할 수 있다.
- 또한, 콜백함수를 활용하면, 중복되는 로직을 대부분 없앨 수 있다.
- 예를 들면, repeat 라는 함수가 있을 때, 해당 결과를 2배, 3배로 다르게 출력해야되는 요구사항이 있을 수 있다.

```js
// 수정 전
function repeat(count) {
  for (let idx = 1; idx <= count; idx++) {
    console.log(idx);
  }
}

function repeatDouble(count) {
  for (let idx = 1; idx <= count; idx++) {
    console.log(idx * 2);
  }
}

function repeatTriple(count) {
  for (let idx = 1; idx <= count; idx++) {
    console.log(idx * 3);
  }
}

repeat(5);
repeatDouble(5);
repeatTriple(5);

// 콜백함수 적용 후
function repeat(count, callback) {
  for (let idx = 1; idx <= count; idx++) {
    callback(idx);
  }
}

repeat(5, function (idx) {
  console.log(idx);
});

repeat(5, function (idx) {
  console.log(idx * 2);
});

repeat(5, function (idx) {
  console.log(idx * 3);
});
```

- 이를 통해서 콜백함수를 활용 시 중복되는 함수 로직을 최소화 할 수 있다라는 이점에 대해서 알 수 있었다.

### ⭐ 스코프

- 변수나 함수에 접근하거나 호출할 수 있는 범위를 말함.
- 자바스크립트에서는 크게 "전역 스코프" 와 "지역 스코프"로 구분된다.
- 전역 스코프 : 전구역에서 접근이 가능.
- 지역 스코프 : 특정 영역에서만 접근이 가능.
- 지역을 구분 짓는 것은 블록(중괄호) 이며, 블록 안에 변수는 지역 스코프를 갖고, 블록 밖의 변수는 전역 스코프를 갖는다.
- 함수는 중복 함수와 같이 함수 내 선언 시 지역 스코프를 갖고 이외의 블록에서는 전역 스코프를 갖게되어 외부에서도 호출이 가능하다.
- 하지만, 함수 이외의 블록 내에서 함수를 선언하는 경우는 거의 없기 때문에, 지역 스코프로 이해해도 무방하다.

### ⭐ 객체

- 원시 타입이 아닌 객체 타입의 자료형
- 여러가지 값을 동시에 저장할 수 있는 자료형
- 실존하는 개념을 표현하기에 용이하다.
- 객체 생성
  - 객체 생성자식(new Object())
  - 객체 리터럴 ({}) → 주로 사용
- 객체 프로퍼티
  - 객체의 속성을 의미하며, K-V 형태로 저장.
  - 갯수 및 타입 제한이 없음.
  - 키값은 보통 따옴표 없이 선언하는데, 띄워쓰기를 사용할 경우, 따옴표가 필요함.
- 객체 프로퍼티 사용법
  - 접근 : 점 표기법 , 괄호 표기법
    - 점 : 객체.프로퍼티(키)
    - 괄호 : 객체["프로퍼티(키)"]
  - 추가 : 점 표기법, 괄호 표기법
    - 점 : 객체.프로퍼티(새로운키) = 새로운 값
    - 괄호 : 객체["프로퍼티(새로운키)"] = 새로운 값
  - 수정 : 점, 괄호
    - 점 : 객체.프로퍼티(키) = 새로운 값
    - 괄호 : 객체["프로퍼티(키)"] = 새로운 값
  - 삭제 : delete
    - 점 : delete 객체.프로퍼티(키)
    - 괄호 : delete 객체["프로퍼티(키)"]
- 프로퍼티 존재 유무 확인
  - in 연산자 ex) "프로퍼티명" in 객체
  - boolean 반환
- 상수 객체 : 상수에 객체를 저장해 놓은 형태
  - 객체를 새롭게 생성하는 것은 불가하지만, 객체 내부 프로퍼티를 사용하는 것은 가능.
- 메서드 : 객체 내부에 정의된 프로퍼티 중 함수 타입의 프로퍼티.

  - 메서드는 보통 객체의 동작을 정의할 때 사용.
  - 메서드 선언 방법

  ```js
  const person = {
    sayHi() {
      console.log("안녕");
    },
  };

  person.sayHi(); // 안녕
  person["sayHi"](); // 안녕
  ```

### ⭐ 배열

- 객체와 동일하게 여러개의 값을 **순차적**으로 담을 수 있는 자료형
- 순차적으로 담기 때문에, 순서(인덱스)가 존재함.
- 배열 생성
  - 배열 생성자(new Array())
  - 배열 리터럴([]) → 대부분 사용
- 접근 시, 배열[인덱스]로 접근하면 됨.
